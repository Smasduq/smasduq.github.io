<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smasduq - The Hangman Challenge</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // --- Theme Application and Synchronous Init ---
        
        // This function will be defined globally and available after this script runs
        window.updateThemeIcons = function(isDark) {
            const icons = [
                { type: 'sun', id: 'sun-icon-desktop' },
                { type: 'moon', id: 'moon-icon-desktop' },
                { type: 'sun', id: 'sun-icon-mobile' },
                { type: 'moon', id: 'moon-icon-mobile' },
                { type: 'sun', id: 'sun-icon-drawer' },
                { type: 'moon', id: 'moon-icon-drawer' },
            ];
            icons.forEach(icon => {
                const el = document.getElementById(icon.id);
                if (!el) return;
                const shouldShow = (isDark && icon.type === 'moon') || (!isDark && icon.type === 'sun');
                el.style.display = shouldShow ? 'inline' : 'none';
            });
        };

        window.applyTheme = function(isDark) {
            if (isDark) {
                document.documentElement.classList.add('dark');
                localStorage.setItem('theme', 'dark');
            } else {
                document.documentElement.classList.remove('dark');
                localStorage.setItem('theme', 'light');
            }
            // Update icons immediately if called from an interaction (like a button click)
            if (document.readyState === 'complete' || document.readyState === 'interactive') {
                window.updateThemeIcons(isDark);
            }
        };

        window.toggleTheme = function() {
            const isDark = document.documentElement.classList.contains('dark');
            window.applyTheme(!isDark);
        };
        
        // IIFE runs synchronously to apply the class immediately, preventing FOUC.
        (function initThemeSync() {
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            let isDark = false;
            
            if (savedTheme === 'dark') isDark = true;
            else if (savedTheme === 'light') isDark = false;
            else isDark = prefersDark;

            // Apply theme class directly and synchronously
            if (isDark) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        })();

        // Once the DOM is loaded, run the icon update logic
        document.addEventListener('DOMContentLoaded', function() {
            const isDark = document.documentElement.classList.contains('dark');
            window.updateThemeIcons(isDark);
        });
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #6366f1; /* Indigo-500 */
            --primary-dark: #4f46e5; /* Indigo-600 */
        }
        body {
            font-family: 'Inter', sans-serif;
            transition: background-color 0.3s, color 0.3s;
        }
        header {
            position: sticky;
            top: 0;
            z-index: 50;
            margin: 0;
        }
        .mono-font {
            font-family: 'Space Mono', monospace;
        }
        .hangman-container {
            background-color: #0f172a; /* Slate-900 */
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        #word-display {
            letter-spacing: 0.75rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        .letter-btn {
            transition: all 0.1s ease-in-out;
            transform: scale(1);
            box-shadow: 0 4px var(--primary-dark);
            border-bottom: 2px solid var(--primary-dark);
        }
        .letter-btn:hover:not(:disabled) {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 6px var(--primary-dark);
        }
        .letter-btn:active:not(:disabled) {
            transform: translateY(2px) scale(0.98);
            box-shadow: 0 2px var(--primary-dark);
        }
        .letter-btn:disabled {
            cursor: not-allowed;
            opacity: 0.7;
            transform: none;
            box-shadow: none;
            border-bottom: none;
        }
        .win-btn {
            background-color: #10b981 !important; /* Emerald-500 */
            box-shadow: 0 4px #059669 !important; /* Emerald-600 */
        }
        .lose-btn {
            background-color: #ef4444 !important; /* Red-500 */
            box-shadow: 0 4px #dc2626 !important; /* Red-600 */
        }

        /* Fallback colors for elements that don't switch properly */
        html:not(.dark) .bg-white { background-color: #ffffff !important; }
        html:not(.dark) .bg-gray-50 { background-color: #f9fafb !important; }
        html:not(.dark) .bg-gray-100 { background-color: #f3f4f6 !important; }
        html:not(.dark) .bg-gray-200 { background-color: #e5e7eb !important; }
        html:not(.dark) .bg-gray-800 { background-color: transparent !important; }
        html:not(.dark) .bg-gray-900 { background-color: transparent !important; }

        html:not(.dark) .text-gray-900 { color: #0f172a !important; }
        html:not(.dark) .text-gray-800 { color: #1f2937 !important; }
        html:not(.dark) .text-gray-700 { color: #374151 !important; }
        html:not(.dark) .text-gray-600 { color: #4b5563 !important; }
        html:not(.dark) .text-gray-500 { color: #6b7280 !important; }
        html:not(.dark) .text-gray-400 { color: #9ca3af !important; }
        html:not(.dark) .text-gray-300 { color: #d1d5db !important; }
        html:not(.dark) .text-gray-100 { color: #f3f4f6 !important; }

        /* Buttons/CTAs fallbacks */
        html:not(.dark) .dark\:bg-indigo-500, html:not(.dark) .bg-indigo-600 { background-color: #4f46e5 !important; }
        html:not(.dark) .dark\:bg-indigo-600, html:not(.dark) .bg-indigo-500 { background-color: #6366f1 !important; }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-100 min-h-screen flex flex-col  justify-center p-4">

    <!-- Header (Navigation/Back Button) -->
    <header class="bg-white dark:bg-gray-800 shadow-xl border-b border-gray-100 dark:border-gray-800">
        <nav class="container mx-auto px-6 py-4">
            <!-- Back to Game Zone Icon Link (Reusing the structure from the previous example) -->
            <a href="#" onclick="window.history.back()" title="Back to Game Zone" class="text-indigo-600 dark:text-indigo-400 p-2 rounded-full transition duration-300 
                hover:text-indigo-500 dark:hover:text-indigo-300 
                hover:bg-indigo-100/20 dark:hover:bg-indigo-900/40 
                transform hover:scale-110 
                inline-flex items-center shadow-lg hover:shadow-xl">
                
                <!-- Arrow Left SVG for clear back navigation -->
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-1.5">
                    <line x1="19" y1="12" x2="5" y2="12"></line>
                    <polyline points="12 19 5 12 12 5"></polyline>
                </svg>
                
                <!-- Gamepad Icon SVG -->
                <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-7 h-7">
                    <rect x="2" y="4" width="20" height="16" rx="3" ry="3"></rect>
                    <line x1="6" y1="10" x2="6" y2="14"></line>
                    <line x1="8" y1="12" x2="4" y2="12"></line>
                    <line x1="18" y1="10" x2="18" y2="14"></line>
                    <line x1="20" y1="12" x2="16" y2="12"></line>
                    <line x1="10" y1="16" x2="14" y2="16"></line>
                    <line x1="12" y1="18" x2="12" y2="14"></line>
                </svg>
                <span class="sr-only">Back to Game Zone</span>
            </a>
        </nav>
    </header>

    <main class="w-full max-w-4xl mx-auto py-10">
        <div class="max-w-xl mx-auto text-center">
            <h1 class="text-5xl font-extrabold text-gray-900 dark:text-white mb-3">HANGMAN</h1>
            <p class="text-xl text-indigo-600 dark:text-indigo-400 font-semibold mb-8">The Hangman Challenge</p>
            
            <div id="game-area" class="bg-white dark:bg-gray-800 p-6 sm:p-10 rounded-3xl shadow-2xl transition duration-300 border-t-4 border-indigo-500">
                
                <!-- Category Display -->
                <p id="category-display" class="text-lg font-bold mb-4 text-indigo-700 dark:text-indigo-300 h-6">
                    <!-- Category will be inserted here -->
                </p>

                <!-- Hangman Drawing Canvas -->
                <div class="flex justify-center mb-6">
                    <div class="hangman-container p-4">
                        <canvas id="hangmanCanvas" width="200" height="250"></canvas>
                    </div>
                </div>

                <div class="mb-6 py-4 border-y-2 border-dashed border-gray-300 dark:border-gray-700">
                    <p id="word-display" class="mono-font text-5xl sm:text-6xl font-bold text-gray-900 dark:text-gray-100 uppercase break-all" style="min-height: 50px;">
                        <!-- Word placeholder/display -->
                    </p>
                </div>

                <div class="flex justify-between items-center mb-6 text-lg font-medium">
                    <span class="text-gray-600 dark:text-gray-300">Strikes: <span id="strikes-left" class="text-red-500 font-extrabold">6</span> / 6</span>
                    <span class="text-gray-600 dark:text-gray-300">Guessed: <span id="guessed-letters" class="text-blue-500 font-bold mono-font text-sm">--</span></span>
                </div>

                <p id="message" class="text-xl font-semibold mb-6 text-indigo-600 dark:text-indigo-400">Click START to begin!</p>
                
                <div id="letter-buttons" class="grid grid-cols-6 sm:grid-cols-7 gap-2 sm:gap-3">
                    <!-- Buttons will be rendered here -->
                </div>
                
                <button id="start-button" class="mt-8 w-full win-btn text-white p-3 rounded-xl text-xl font-extrabold transition duration-200">START GAME</button>
            </div>
        </div>
    </main>

    <script>
        // --- Game Data ---
        const wordData = {
            "Programming": [
                "PYTHON", "JAVASCRIPT", "TAILWIND", "ALGORITHM", 
                "VARIABLE", "FUNCTION", "PROMISE", "SYNTAX", 
                "COMPILER", "OBJECT", "BOOLEAN", "FIREBASE", 
                "RECURSION", "ASYNC", "ANGULAR", "REACT"
            ],
            "Technology": [
                "NETWORK", "PROTOCOL", "BANDWIDTH", "CLOUD", 
                "SERVER", "CLIENT", "FRONTEND", "HARDWARE",
                "SOFTWARE", "ROUTER", "MODEM", "WIFI", "ETHERNET", 
                "DEVOPS", "CYBER", "MACHINE"
            ],
            "Abstract Terms": [
                "MYSTERY", "CALENDAR", "ADVENTURE", "QUARTZ", 
                "BLIZZARD", "WHISKEY", "GAZETTE", "JAZZ", 
                "OXYGEN", "ABYSS", "CRYPT", "GALVANIZED", 
                "ZEPHYR", "PHANTOM", "EXODUS", "UNKNOWN"
            ]
        };
        const MAX_STRIKES = 6;
        const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

        // Flatten the word data into a single array of { word, category } objects
        let DICTIONARY = [];
        for (const category in wordData) {
            DICTIONARY.push(...wordData[category].map(word => ({ word, category })));
        }

        // --- Game State Variables ---
        let secretWord = '';
        let revealedWord = [];
        let strikes = 0;
        let guessedLetters = [];
        let isGameOver = true;
        let currentCategory = '';

        // --- DOM Elements ---
        const wordDisplay = document.getElementById('word-display');
        const strikesLeft = document.getElementById('strikes-left');
        const guessedLettersDisplay = document.getElementById('guessed-letters');
        const letterButtonsContainer = document.getElementById('letter-buttons');
        const message = document.getElementById('message');
        const startButton = document.getElementById('start-button');
        const categoryDisplay = document.getElementById('category-display');
        
        // Canvas Setup
        const hangmanCanvas = document.getElementById('hangmanCanvas');
        const ctx = hangmanCanvas.getContext('2d');


        // --- Canvas Drawing Functions ---

        /**
         * Draws the empty gallows structure.
         */
        function drawGallows() {
            ctx.clearRect(0, 0, hangmanCanvas.width, hangmanCanvas.height);
            ctx.strokeStyle = '#f1f5f9'; // Light color for drawing (off-white)
            ctx.lineWidth = 4;
            
            const [w, h] = [hangmanCanvas.width, hangmanCanvas.height];
            const base = h - 20;
            const top = 30;
            const center = w / 2;
            const ropeOffset = 50; // Horizontal offset from center for the main pole
            
            // Base
            ctx.beginPath();
            ctx.moveTo(w / 4, base);
            ctx.lineTo(w * 3 / 4, base);
            ctx.stroke();

            // Vertical pole
            ctx.beginPath();
            ctx.moveTo(center - ropeOffset, base);
            ctx.lineTo(center - ropeOffset, top);
            ctx.stroke();
            
            // Top beam
            ctx.beginPath();
            ctx.moveTo(center - ropeOffset, top);
            ctx.lineTo(center, top);
            ctx.stroke();
            
            // Rope
            ctx.beginPath();
            ctx.lineWidth = 3;
            ctx.moveTo(center, top);
            ctx.lineTo(center, top + 25);
            ctx.stroke();
        }

        /**
         * Draws the Hangman parts based on wrong guesses.
         */
        function drawHangmanPart(partIndex) {
            ctx.strokeStyle = '#ef4444'; // Red color for the body (Tailwind red-500)
            ctx.lineWidth = 4;
            
            const center = hangmanCanvas.width / 2;
            const ropeHeight = 25;
            const headY = 30 + ropeHeight + 15;
            const bodyY = headY + 15;

            switch(partIndex) {
                case 1: // Head
                    ctx.beginPath();
                    ctx.arc(center, headY, 15, 0, Math.PI * 2, true);
                    ctx.stroke();
                    break;
                case 2: // Body
                    ctx.beginPath();
                    ctx.moveTo(center, headY + 15);
                    ctx.lineTo(center, bodyY + 50);
                    ctx.stroke();
                    break;
                case 3: // Left Arm
                    ctx.beginPath();
                    ctx.moveTo(center, bodyY + 10);
                    ctx.lineTo(center - 20, bodyY + 30);
                    ctx.stroke();
                    break;
                case 4: // Right Arm
                    ctx.beginPath();
                    ctx.moveTo(center, bodyY + 10);
                    ctx.lineTo(center + 20, bodyY + 30);
                    ctx.stroke();
                    break;
                case 5: // Left Leg
                    ctx.beginPath();
                    ctx.moveTo(center, bodyY + 50);
                    ctx.lineTo(center - 20, bodyY + 80);
                    ctx.stroke();
                    break;
                case 6: // Right Leg (Final piece)
                    ctx.beginPath();
                    ctx.moveTo(center, bodyY + 50);
                    ctx.lineTo(center + 20, bodyY + 80);
                    ctx.stroke();
                    break;
            }
        }


        // --- Game Setup ---
        function initializeGame() {
            if (DICTIONARY.length === 0) {
                message.textContent = "Error: Dictionary is empty.";
                return;
            }

            // Select random word object
            const randomWordObj = DICTIONARY[Math.floor(Math.random() * DICTIONARY.length)];

            secretWord = randomWordObj.word;
            currentCategory = randomWordObj.category;
            revealedWord = Array(secretWord.length).fill('_');
            strikes = 0;
            guessedLetters = [];
            isGameOver = false;
            
            // UI Resets
            drawGallows();
            strikesLeft.textContent = MAX_STRIKES;
            guessedLettersDisplay.textContent = '--';
            categoryDisplay.textContent = `CATEGORY: ${currentCategory.toUpperCase()}`;
            message.textContent = `Guess a letter!`;
            
            // Cleanup message styles
            message.classList.remove('text-green-600', 'text-red-600', 'dark:text-indigo-400');
            message.classList.add('text-indigo-600', 'dark:text-indigo-400');

            startButton.style.display = 'none';

            renderWord();
            renderButtons(true);
        }

        // --- Rendering ---
        function renderWord() {
            wordDisplay.textContent = revealedWord.join(' ');
        }

        function renderButtons(reset = false) {
            if (reset || letterButtonsContainer.innerHTML === '') {
                letterButtonsContainer.innerHTML = '';
                for (let char of ALPHABET) {
                    const button = document.createElement('button');
                    button.textContent = char;
                    // Dynamically setting classes for aesthetic buttons
                    button.className = 'letter-btn bg-indigo-500 text-white p-2 rounded-lg font-bold text-lg uppercase shadow-md';
                    button.setAttribute('data-letter', char);
                    button.addEventListener('click', () => handleGuess(char));
                    letterButtonsContainer.appendChild(button);
                }
            }
            
            // Re-enable all buttons if reset is true
            if (reset) {
                letterButtonsContainer.querySelectorAll('.letter-btn').forEach(btn => {
                    btn.disabled = false;
                    btn.classList.remove('bg-green-500', 'bg-red-500', 'win-btn', 'lose-btn');
                    btn.classList.add('bg-indigo-500');
                });
            }
        }

        function updateButtonState(letter, correct) {
            const button = document.querySelector(`[data-letter="${letter}"]`);
            if (button) {
                button.disabled = true;
                button.classList.remove('bg-indigo-500', 'hover:bg-indigo-600');
                if (correct) {
                    button.classList.add('bg-green-500');
                } else {
                    button.classList.add('bg-red-500');
                }
                // Remove custom button shadows for disabled state
                button.style.boxShadow = 'none';
                button.style.transform = 'none';
            }
        }

        // --- Core Guess Logic ---
        function handleGuess(letter) {
            if (isGameOver || guessedLetters.includes(letter)) return;

            // Disable the button immediately
            const btn = document.querySelector(`[data-letter="${letter}"]`);
            if(btn) btn.disabled = true;

            guessedLetters.push(letter);
            guessedLettersDisplay.textContent = guessedLetters.join(', ');

            let correctGuess = false;
            let indices = [];
            for (let i = 0; i < secretWord.length; i++) {
                if (secretWord[i] === letter) {
                    revealedWord[i] = letter;
                    indices.push(i);
                    correctGuess = true;
                }
            }

            if (correctGuess) {
                renderWord();
                updateButtonState(letter, true);
                if (!revealedWord.includes('_')) {
                    endGame(true); // Win condition
                }
            } else {
                strikes++;
                drawHangmanPart(strikes); // Draw the next part
                strikesLeft.textContent = MAX_STRIKES - strikes;
                updateButtonState(letter, false);
                if (strikes >= MAX_STRIKES) {
                    endGame(false); // Lose condition
                }
            }
        }

        // --- End Game ---
        function endGame(won) {
            isGameOver = true;
            // Disable all remaining buttons
            letterButtonsContainer.querySelectorAll('.letter-btn').forEach(btn => btn.disabled = true);
            
            startButton.textContent = 'Play Again';
            startButton.style.display = 'block';

            // Update Start button style
            startButton.classList.remove('win-btn', 'lose-btn');
            startButton.classList.add(won ? 'win-btn' : 'lose-btn');

            // Update message and word display
            message.classList.remove('text-indigo-600', 'dark:text-indigo-400');
            if (won) {
                message.textContent = `VICTORY! The word was: "${secretWord}"`;
                message.classList.add('text-green-600');
            } else {
                message.textContent = `Game Over! The word was: "${secretWord}"`;
                message.classList.add('text-red-600');
                wordDisplay.textContent = secretWord.split('').join(' '); // Show the word
            }
            categoryDisplay.textContent = `Category: ${currentCategory.toUpperCase()}`;
        }

        // --- Initial Setup on Load ---
        function initialSetup() {
            renderButtons();
            letterButtonsContainer.querySelectorAll('.letter-btn').forEach(btn => btn.disabled = true);
            wordDisplay.textContent = Array(7).fill('_').join(' ');
            categoryDisplay.textContent = ''; // Hide category initially
            drawGallows(); // Draw the empty gallows on load
            startButton.addEventListener('click', initializeGame);
        }

        initialSetup();
    </script>
</body>
</html>